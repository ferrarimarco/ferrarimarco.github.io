<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>An Automatically Configured Development Box</title><meta name=description content="In the past months I was assigned a new task at work, that essentially boileddown to this question: how can we simplify the deployment of new developmentwork..."><link rel=canonical href=http://ferrarimarco.info/blog/development/devops/configuration/2017/07/26/open-development-environment-devbox/ ><link rel=stylesheet href=/assets/stylesheets/style-60a4ec6f84.min.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/assets/images/touch/apple-touch-icon.png><link rel="shortcut icon" href=/favicon.ico><link type=application/atom+xml rel=alternate href=http://ferrarimarco.info/feed.xml title="Marco Ferrari - software engineer"><title>An Automatically Configured Development Box | Marco Ferrari - software engineer</title><meta property=og:title content="An Automatically Configured Development Box"><meta name=author content="Marco Ferrari"><meta property=og:locale content=en_US><meta name=description content="In the past months I was assigned a new task at work, that essentially boiled down to this question: how can we simplify the deployment of new development workstations? In my development team at the time, we were tired of repeating the same (mostly manual and not documented) steps. The configuration process resulted in different development environment leading to confusion (it works on my machine!) and deployment issues. Baseline We were in the situation where each developer, depending on his/her experience, installed and configured a set of development tools at his/her own will. This process was largely undocumented (READMEs were Holy Grails) and led to all sort of environment disparity issues. Moreover the configuration could not be easily changed because of the fear of breaking something. For the same reason no one actually bothered to install upgrades for such tools (we had someone who was stuck on a 3-years-ago Eclipse version!). List of Requirements Automated Setup: there must be no manual steps involved in the setup of a workstation Versioning: the configuration should be stored in a Version Control System Reproducibility: the setup process of a new workstation should be easily reproducible Environments should be ephemeral: each instance should be easily created and destroyed without any loss of configuration Minimize the time needed to spin up a new instance Research After some research, I could not find a out-of-the-box solution or even a set of established best practices to follow. Everyone was (is?) focusing on development environments and not on the configuration process of the development tools. Solution This solution (ferrarimarco/open-development-environment-devbox) is a process that produces a packaged machine with the needed tools already installed and ready to be used. For a list of the available tools refer to the README in ferrarimarco/open-development-environment-devbox. Some of the included tools run inside Docker containers to ease and speed up the setup and deployment. Build To automate the creation of images for various platforms I implemented a Packer template to execute the following tasks: Provision a new machine Start the new machine Install the Operating System Configure the running instance by running provisioning tools Package the machine I chose Packer because it let me write a recipe (a single JSON file called template) to provision and configure the machine in a totally automated way. I just run the packer build command to start the build process. The other interesting Packer feature is that you can use multiple providers ( different hypervisors and/or cloud providers), multiple configuration methods ( shell scripts, Ansible playbooks, Chef recipes, etc.) and different post processors to package the created images. This gives you maximum deployment flexibility (i.e. start with a local virtualized environment and move to a cloud based one in the future). I chose to run the configuration process while building the image so I had to execute this process only once per build and not every time an instance is started. Configuration The configuration process was implemented by developing a set of Ansible roles. I decided to use a dedicated configuration tool (Ansible) instead of writing shell scripts to avoid the complexity of ensuring the compatibility of such scripts across multiple platforms. I also benefited from the built-in node management mechanisms that these dedicated tools implement out-of-the-box. The adoption of this kind of tools has the added plus of letting you reuse your code on different platforms (Virtual Machines, Physical Machines) without much effort. You just need to tell to such tools where your instances are and they will do the rest. Deployment For now I deployed instances of this Development Box in two ways: Virtual Machines managed with Vagrant to manage the life cycle of each instance. You can bring up a new instance in matter of seconds with just vagrant up command; Physical machines, by applying the same set of Ansible roles to a given host. In this case Vagrant can be used as a development environment before applying any role to the production node."><meta property=og:description content="In the past months I was assigned a new task at work, that essentially boiled down to this question: how can we simplify the deployment of new development workstations? In my development team at the time, we were tired of repeating the same (mostly manual and not documented) steps. The configuration process resulted in different development environment leading to confusion (it works on my machine!) and deployment issues. Baseline We were in the situation where each developer, depending on his/her experience, installed and configured a set of development tools at his/her own will. This process was largely undocumented (READMEs were Holy Grails) and led to all sort of environment disparity issues. Moreover the configuration could not be easily changed because of the fear of breaking something. For the same reason no one actually bothered to install upgrades for such tools (we had someone who was stuck on a 3-years-ago Eclipse version!). List of Requirements Automated Setup: there must be no manual steps involved in the setup of a workstation Versioning: the configuration should be stored in a Version Control System Reproducibility: the setup process of a new workstation should be easily reproducible Environments should be ephemeral: each instance should be easily created and destroyed without any loss of configuration Minimize the time needed to spin up a new instance Research After some research, I could not find a out-of-the-box solution or even a set of established best practices to follow. Everyone was (is?) focusing on development environments and not on the configuration process of the development tools. Solution This solution (ferrarimarco/open-development-environment-devbox) is a process that produces a packaged machine with the needed tools already installed and ready to be used. For a list of the available tools refer to the README in ferrarimarco/open-development-environment-devbox. Some of the included tools run inside Docker containers to ease and speed up the setup and deployment. Build To automate the creation of images for various platforms I implemented a Packer template to execute the following tasks: Provision a new machine Start the new machine Install the Operating System Configure the running instance by running provisioning tools Package the machine I chose Packer because it let me write a recipe (a single JSON file called template) to provision and configure the machine in a totally automated way. I just run the packer build command to start the build process. The other interesting Packer feature is that you can use multiple providers ( different hypervisors and/or cloud providers), multiple configuration methods ( shell scripts, Ansible playbooks, Chef recipes, etc.) and different post processors to package the created images. This gives you maximum deployment flexibility (i.e. start with a local virtualized environment and move to a cloud based one in the future). I chose to run the configuration process while building the image so I had to execute this process only once per build and not every time an instance is started. Configuration The configuration process was implemented by developing a set of Ansible roles. I decided to use a dedicated configuration tool (Ansible) instead of writing shell scripts to avoid the complexity of ensuring the compatibility of such scripts across multiple platforms. I also benefited from the built-in node management mechanisms that these dedicated tools implement out-of-the-box. The adoption of this kind of tools has the added plus of letting you reuse your code on different platforms (Virtual Machines, Physical Machines) without much effort. You just need to tell to such tools where your instances are and they will do the rest. Deployment For now I deployed instances of this Development Box in two ways: Virtual Machines managed with Vagrant to manage the life cycle of each instance. You can bring up a new instance in matter of seconds with just vagrant up command; Physical machines, by applying the same set of Ansible roles to a given host. In this case Vagrant can be used as a development environment before applying any role to the production node."><link rel=canonical href=http://ferrarimarco.info/blog/development/devops/configuration/2017/07/26/open-development-environment-devbox/ ><meta property=og:url content=http://ferrarimarco.info/blog/development/devops/configuration/2017/07/26/open-development-environment-devbox/ ><meta property=og:site_name content="Marco Ferrari - software engineer"><meta property=og:type content=article><meta property=article:published_time content=2017-07-26T00:00:00+00:00><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"An Automatically Configured Development Box","author":{"@type":"Person","name":"Marco Ferrari"},"datePublished":"2017-07-26T00:00:00+00:00","dateModified":"2017-07-26T00:00:00+00:00","description":"In the past months I was assigned a new task at work, that essentially boiled down to this question: how can we simplify the deployment of new development workstations? In my development team at the time, we were tired of repeating the same (mostly manual and not documented) steps. The configuration process resulted in different development environment leading to confusion (it works on my machine!) and deployment issues. Baseline We were in the situation where each developer, depending on his/her experience, installed and configured a set of development tools at his/her own will. This process was largely undocumented (READMEs were Holy Grails) and led to all sort of environment disparity issues. Moreover the configuration could not be easily changed because of the fear of breaking something. For the same reason no one actually bothered to install upgrades for such tools (we had someone who was stuck on a 3-years-ago Eclipse version!). List of Requirements Automated Setup: there must be no manual steps involved in the setup of a workstation Versioning: the configuration should be stored in a Version Control System Reproducibility: the setup process of a new workstation should be easily reproducible Environments should be ephemeral: each instance should be easily created and destroyed without any loss of configuration Minimize the time needed to spin up a new instance Research After some research, I could not find a out-of-the-box solution or even a set of established best practices to follow. Everyone was (is?) focusing on development environments and not on the configuration process of the development tools. Solution This solution (ferrarimarco/open-development-environment-devbox) is a process that produces a packaged machine with the needed tools already installed and ready to be used. For a list of the available tools refer to the README in ferrarimarco/open-development-environment-devbox. Some of the included tools run inside Docker containers to ease and speed up the setup and deployment. Build To automate the creation of images for various platforms I implemented a Packer template to execute the following tasks: Provision a new machine Start the new machine Install the Operating System Configure the running instance by running provisioning tools Package the machine I chose Packer because it let me write a recipe (a single JSON file called template) to provision and configure the machine in a totally automated way. I just run the packer build command to start the build process. The other interesting Packer feature is that you can use multiple providers ( different hypervisors and/or cloud providers), multiple configuration methods ( shell scripts, Ansible playbooks, Chef recipes, etc.) and different post processors to package the created images. This gives you maximum deployment flexibility (i.e. start with a local virtualized environment and move to a cloud based one in the future). I chose to run the configuration process while building the image so I had to execute this process only once per build and not every time an instance is started. Configuration The configuration process was implemented by developing a set of Ansible roles. I decided to use a dedicated configuration tool (Ansible) instead of writing shell scripts to avoid the complexity of ensuring the compatibility of such scripts across multiple platforms. I also benefited from the built-in node management mechanisms that these dedicated tools implement out-of-the-box. The adoption of this kind of tools has the added plus of letting you reuse your code on different platforms (Virtual Machines, Physical Machines) without much effort. You just need to tell to such tools where your instances are and they will do the rest. Deployment For now I deployed instances of this Development Box in two ways: Virtual Machines managed with Vagrant to manage the life cycle of each instance. You can bring up a new instance in matter of seconds with just vagrant up command; Physical machines, by applying the same set of Ansible roles to a given host. In this case Vagrant can be used as a development environment before applying any role to the production node.","mainEntityOfPage":{"@type":"WebPage","@id":"http://ferrarimarco.info/blog/development/devops/configuration/2017/07/26/open-development-environment-devbox/"},"url":"http://ferrarimarco.info/blog/development/devops/configuration/2017/07/26/open-development-environment-devbox/"}</script><link href="http://fonts.googleapis.com/css?family=Roboto+Slab|Roboto" rel=stylesheet type=text/css></head><body><header class=site-header><div class=wrapper><!--[if lt IE 11]>
      <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]--> <a class=site-title href=/ >Marco Ferrari - software engineer</a><nav class=site-nav><div class=trigger><a class=page-link href=/blog/ >Blog</a></div></nav></div></header><div class=page-content><div class=wrapper><article class=post itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">An Automatically Configured Development Box</h1><p class=post-meta><time datetime=2017-07-26T00:00:00+00:00 itemprop=datePublished>Jul 26, 2017</time></p></header><div class=post-content itemprop=articleBody><p>In the past months I was assigned a new task at work, that essentially boiled down to this question: <em>how can we simplify the deployment of new development workstations?</em></p><p>In my development team at the time, we were tired of repeating the same (mostly manual and not documented) steps. The configuration process resulted in different development environment leading to confusion (it works on my machine!) and deployment issues.</p><h2 id=baseline>Baseline</h2><p>We were in the situation where each developer, depending on his/her experience, installed and configured a set of development tools at his/her own will. This process was largely undocumented (READMEs were Holy Grails) and led to all sort of environment disparity issues. Moreover the configuration could not be easily changed because of the fear of breaking something. For the same reason no one actually bothered to install upgrades for such tools (we had someone who was stuck on a 3-years-ago Eclipse version!).</p><h2 id=list-of-requirements>List of Requirements</h2><ol><li>Automated Setup: there must be no manual steps involved in the setup of a workstation</li><li>Versioning: the configuration should be stored in a Version Control System</li><li>Reproducibility: the setup process of a new workstation should be easily reproducible</li><li>Environments should be ephemeral: each instance should be easily created and destroyed without any loss of configuration</li><li>Minimize the time needed to spin up a new instance</li></ol><h2 id=research>Research</h2><p>After some research, I could not find a out-of-the-box solution or even a set of established best practices to follow. Everyone was (is?) focusing on <em>development environments</em> and not on the configuration process of the development tools.</p><h2 id=solution>Solution</h2><p>This solution (<a href=https://github.com/ferrarimarco/open-development-environment-devbox>ferrarimarco/open-development-environment-devbox</a>) is a process that produces a packaged machine with the needed tools already installed and ready to be used. For a list of the available tools refer to the README in <a href=https://github.com/ferrarimarco/open-development-environment-devbox>ferrarimarco/open-development-environment-devbox</a>.</p><p>Some of the included tools run inside <a href=https://www.docker.com/ >Docker</a> containers to ease and speed up the setup and deployment.</p><h3 id=build>Build</h3><p>To automate the creation of images for various platforms I implemented a <a href=https://www.packer.io>Packer</a> template to execute the following tasks:</p><ol><li>Provision a new machine</li><li>Start the new machine</li><li>Install the Operating System</li><li>Configure the running instance by running provisioning tools</li><li>Package the machine</li></ol><p>I chose Packer because it let me write a recipe (a single JSON file called <em>template</em>) to provision and configure the machine in a totally automated way. I just run the <code class=highlighter-rouge>packer build</code> command to start the build process.</p><p>The other interesting Packer feature is that you can use multiple providers ( different hypervisors and/or cloud providers), multiple configuration methods ( shell scripts, <a href=https://www.ansible.com/ >Ansible</a> playbooks, Chef recipes, etc.) and different post processors to package the created images. This gives you maximum deployment flexibility (i.e. start with a local virtualized environment and move to a cloud based one in the future).</p><p>I chose to run the configuration process while building the image so I had to execute this process only once per build and not every time an instance is started.</p><h3 id=configuration>Configuration</h3><p>The configuration process was implemented by developing a set of <a href=https://www.ansible.com/ >Ansible</a> roles. I decided to use a dedicated configuration tool (<a href=https://www.ansible.com/ >Ansible</a>) instead of writing shell scripts to avoid the complexity of ensuring the compatibility of such scripts across multiple platforms. I also benefited from the built-in node management mechanisms that these dedicated tools implement out-of-the-box.</p><p>The adoption of this kind of tools has the added plus of letting you reuse your code on different platforms (Virtual Machines, Physical Machines) without much effort. You just need to tell to such tools where your instances are and they will do the rest.</p><h3 id=deployment>Deployment</h3><p>For now I deployed instances of this Development Box in two ways:</p><ol><li>Virtual Machines managed with <a href=https://www.vagrantup.com>Vagrant</a> to manage the life cycle of each instance. You can bring up a new instance in matter of seconds with just <code class=highlighter-rouge>vagrant up</code> command;</li><li>Physical machines, by applying the same set of <a href=https://www.ansible.com/ >Ansible</a> roles to a given host. In this case <a href=https://www.vagrantup.com>Vagrant</a> can be used as a development environment before applying any role to the production node.</li></ol></div><div class="post-footer post-meta"><p>Categories: <a href=/blog/archive/category/development/ >development</a> <a href=/blog/archive/category/devops/ >devops</a> <a href=/blog/archive/category/configuration/ >configuration</a></p><p>Tags: <a href=/blog/archive/tag/ansible/ >ansible</a> <a href=/blog/archive/tag/docker/ >docker</a> <a href=/blog/archive/tag/vagrant/ >vagrant</a></p><p>Subscribe <a href=/feed.xml>via RSS</a></p></div></article></div></div><footer class=site-footer><div class=wrapper><h2 class=footer-heading>Contacts</h2><div class=footer-col-wrapper><div class=footer-col><ul class=contact-list><li>Marco Ferrari - <a href=https://goo.gl/zXJzFp class=bold>CV</a></li><li><a href=mailto:ferrari.marco@gmail.com><span class=icon><img src=/assets/images/contacts/email.png> </span><span class=username>Email: ferrari.marco@gmail.com</span></a></li><li><a href=https://github.com/ferrarimarco rel=me><span class=icon><img src=/assets/images/contacts/github.png> </span><span class=username>Github: ferrarimarco</span></a></li><li><a href=https://www.facebook.com/ferrari.marco rel=me><span class=icon><img src=/assets/images/contacts/facebook.png> </span><span class=username>Facebook: ferrari.marco</span></a></li><li><a href="https://twitter.com/Marco Ferrari" rel=me><span class=icon><img src=/assets/images/contacts/twitter.png> </span><span class=username>Twitter: Marco Ferrari</span></a></li><li><a href=https://www.linkedin.com/in/ferrarimark rel=me><span class=icon><img src=/assets/images/contacts/linkedin.png> </span><span class=username>Linkedin: ferrarimark</span></a></li><li><a href=https://stackoverflow.com/users/653462 rel=me><span class=icon><img src=/assets/images/contacts/stackoverflow.png> </span><span class=username>Stackoverflow: marco-ferrari</span></a></li><li><a href=https://keybase.io/ferrarimarco rel=me><span class=icon><img src=/assets/images/contacts/keybase.png> </span><span class=username>Keybase: ferrarimarco</span></a></li></ul></div></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
    function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
    e=o.createElement(i);r=o.getElementsByTagName(i)[0];
    e.src='//www.google-analytics.com/analytics.js';
    r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
    ga('create','UA-18832248-1');ga('send','pageview');</script><script src=/assets/javascript/index-8971778a9c.min.js></script></body></html>