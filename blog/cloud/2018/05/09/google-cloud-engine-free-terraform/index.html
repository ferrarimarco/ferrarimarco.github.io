<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Marco Ferrari - software engineer | Bootstrapping a Cluster on Google Cloud with Terraform</title><meta name=description content="Recently I had to evaluate cloud computing offers for a new project.I started with Google Cloud Platform.Google Cloud: Free TierFor my evaluation goals the a..."><link rel=canonical href=https://ferrarimarco.info/blog/cloud/2018/05/09/google-cloud-engine-free-terraform/ ><link rel=stylesheet href=/assets/stylesheets/style-b38b207984.min.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/assets/images/touch/apple-touch-icon.png><link rel="shortcut icon" href=/favicon.ico><link type=application/atom+xml rel=alternate href=https://ferrarimarco.info/feed.xml title="Marco Ferrari - software engineer"><title>Bootstrapping a Cluster on Google Cloud with Terraform | Marco Ferrari - software engineer</title><meta name=generator content="Jekyll v3.8.1"><meta property=og:title content="Bootstrapping a Cluster on Google Cloud with Terraform"><meta name=author content="Marco Ferrari"><meta property=og:locale content=en_US><meta name=description content="Recently I had to evaluate cloud computing offers for a new project. I started with Google Cloud Platform. Google Cloud: Free Tier For my evaluation goals the always-free tier was enough. This free tier has many perks (at IaaS and PaaS), but for this exercise we will use: 1x free f1-micro VM on Compute Engine with 30GB of disk space 5GB of Google Cloud Storage Goals We are going to bootstrap a 1-VM cluster on Google Cloud Compute Engine using Terraform. The VM will have a 30GB hard disk. Terraform Terraform is tool to automate the provision of cloud infrastructures. Basically it translate a descriptor (Configurations in Terraform jargon) in calls to the chosen cloud provider API. The fancy name for this management process is “Infrastructure as Code”. Infrastructure as Code Why should you describe your infrastructure with code? For three reasons: It will be auditable: you know what’s in there It can be versioned: you can control the changes It can automatically processed: there are tools that can process your infrastructure descriptors and automatically apply changes Terraform Configurations The whole project is available on GitHub: ferrarimarco/google-cloud-playground Being this a really simple infrastructure, we used just three configurations Resources: gce.tf Outputs: outputs.tf Variables: variables.tf Resources In this configuration we define the following resources: A backend Default provider credentials A reginal Google Compute Engine IP Address A Virtual Machine Backend A backend is needed to share the Terraform state, if you want to collaborate with others on the management activities of the infrastructure. You could avoid setting up a backend (Terraform will use a local backend by default), but then you need to deal with the inevitable merging conflicts due to Terraform executions by different users. I configured it because with a remote backend I’m able to modify my infrastructure from any workstation. To keep this in the same infrastructure, I manually created a Google Cloud Storage bucket and configured it in the resources configuration as: terraform { backend &quot;gcs&quot; { credentials = &quot;account.json&quot; prefix = &quot;terraform/state&quot; } } where account.json is a credential file created as described in the README. Default Provider Configuration These are the default settings that we configured for the Google Cloud provider. Can be overridden by other resources. provider &quot;google&quot; { credentials = &quot;${file(&quot;account.json&quot;)}&quot; project = &quot;${var.project_id}&quot; region = &quot;us-east1&quot; zone = &quot;us-east1-b&quot; } Note the use of variables (${}). We’ll explain this later. Google Compute Engine: IP Address and VM Now let’s get to the meat: the Virtual Machine and its public IP address. The syntax is straightforward. resource &quot;google_compute_address&quot; &quot;regional-m1-ip&quot; { name = &quot;regional-m1-ip&quot; } resource &quot;google_compute_instance&quot; &quot;gce-free-tier&quot; { name = &quot;gce1&quot; machine_type = &quot;f1-micro&quot; tags = [&quot;free-tier&quot;] boot_disk { auto_delete = true initialize_params { image = &quot;ubuntu-os-cloud/ubuntu-1804-bionic-v20180426b&quot; size = 30 type = &quot;pd-standard&quot; } } metadata { ssh-keys = &quot;${var.ssh_user}:${file(&quot;${var.public_key_path}&quot;)}&quot; } network_interface { access_config { nat_ip = &quot;${google_compute_address.regional-m1-ip.address}&quot; } subnetwork = &quot;default&quot; } service_account { scopes = [ &quot;https://www.googleapis.com/auth/devstorage.read_only&quot;, &quot;https://www.googleapis.com/auth/logging.write&quot;, &quot;https://www.googleapis.com/auth/monitoring.write&quot;, &quot;https://www.googleapis.com/auth/servicecontrol&quot;, &quot;https://www.googleapis.com/auth/service.management.readonly&quot;, &quot;https://www.googleapis.com/auth/trace.append&quot; ] } } A couple of notes: Terraform does not yet support OS-Login. We are stuck with Metadata-based logins (hence the setup of metadata) in the configuration Region and image id should be parametrized with variables as well Outputs With Terraform we can define the outputs of each terraform apply run. In this case it’s useful to get, for each VM, its id public IP address so we can connect to continue with the configuration. output &quot;instances&quot; { value = &quot;${join(&quot;,&quot;, google_compute_instance.gce-free-tier.*.instance_id, google_compute_instance.gce-free-tier.*.network_interface.0.address, google_compute_instance.gce-free-tier.*.network_interface.0.access_config.0.assigned_nat_ip)}&quot; } Variables To avoid hard coding values in the configuration, I used a separate file to define runtime variables that can be overridden if necessary: variable &quot;public_key_path&quot; { description = &quot;Path to file containing public key&quot; default = &quot;~/.ssh/id_rsa_gcloud.pub&quot; } variable &quot;private_key_path&quot; { description = &quot;Path to file containing private key&quot; default = &quot;~/.ssh/id_rsa_gcloud&quot; } variable &quot;project_id&quot; { description = &quot;Google Cloud Project ID&quot; } variable &quot;ssh_user&quot; { description = &quot;SSH User&quot; } Conclusions I showed you how to automatically setup a completely free (but somewhat limited) 1-VM cluster in Google Cloud and Terraform. Keep up with the updates in the GitHub repository: I’m going to expand the cluster with more Google Cloud free tier perks."><meta property=og:description content="Recently I had to evaluate cloud computing offers for a new project. I started with Google Cloud Platform. Google Cloud: Free Tier For my evaluation goals the always-free tier was enough. This free tier has many perks (at IaaS and PaaS), but for this exercise we will use: 1x free f1-micro VM on Compute Engine with 30GB of disk space 5GB of Google Cloud Storage Goals We are going to bootstrap a 1-VM cluster on Google Cloud Compute Engine using Terraform. The VM will have a 30GB hard disk. Terraform Terraform is tool to automate the provision of cloud infrastructures. Basically it translate a descriptor (Configurations in Terraform jargon) in calls to the chosen cloud provider API. The fancy name for this management process is “Infrastructure as Code”. Infrastructure as Code Why should you describe your infrastructure with code? For three reasons: It will be auditable: you know what’s in there It can be versioned: you can control the changes It can automatically processed: there are tools that can process your infrastructure descriptors and automatically apply changes Terraform Configurations The whole project is available on GitHub: ferrarimarco/google-cloud-playground Being this a really simple infrastructure, we used just three configurations Resources: gce.tf Outputs: outputs.tf Variables: variables.tf Resources In this configuration we define the following resources: A backend Default provider credentials A reginal Google Compute Engine IP Address A Virtual Machine Backend A backend is needed to share the Terraform state, if you want to collaborate with others on the management activities of the infrastructure. You could avoid setting up a backend (Terraform will use a local backend by default), but then you need to deal with the inevitable merging conflicts due to Terraform executions by different users. I configured it because with a remote backend I’m able to modify my infrastructure from any workstation. To keep this in the same infrastructure, I manually created a Google Cloud Storage bucket and configured it in the resources configuration as: terraform { backend &quot;gcs&quot; { credentials = &quot;account.json&quot; prefix = &quot;terraform/state&quot; } } where account.json is a credential file created as described in the README. Default Provider Configuration These are the default settings that we configured for the Google Cloud provider. Can be overridden by other resources. provider &quot;google&quot; { credentials = &quot;${file(&quot;account.json&quot;)}&quot; project = &quot;${var.project_id}&quot; region = &quot;us-east1&quot; zone = &quot;us-east1-b&quot; } Note the use of variables (${}). We’ll explain this later. Google Compute Engine: IP Address and VM Now let’s get to the meat: the Virtual Machine and its public IP address. The syntax is straightforward. resource &quot;google_compute_address&quot; &quot;regional-m1-ip&quot; { name = &quot;regional-m1-ip&quot; } resource &quot;google_compute_instance&quot; &quot;gce-free-tier&quot; { name = &quot;gce1&quot; machine_type = &quot;f1-micro&quot; tags = [&quot;free-tier&quot;] boot_disk { auto_delete = true initialize_params { image = &quot;ubuntu-os-cloud/ubuntu-1804-bionic-v20180426b&quot; size = 30 type = &quot;pd-standard&quot; } } metadata { ssh-keys = &quot;${var.ssh_user}:${file(&quot;${var.public_key_path}&quot;)}&quot; } network_interface { access_config { nat_ip = &quot;${google_compute_address.regional-m1-ip.address}&quot; } subnetwork = &quot;default&quot; } service_account { scopes = [ &quot;https://www.googleapis.com/auth/devstorage.read_only&quot;, &quot;https://www.googleapis.com/auth/logging.write&quot;, &quot;https://www.googleapis.com/auth/monitoring.write&quot;, &quot;https://www.googleapis.com/auth/servicecontrol&quot;, &quot;https://www.googleapis.com/auth/service.management.readonly&quot;, &quot;https://www.googleapis.com/auth/trace.append&quot; ] } } A couple of notes: Terraform does not yet support OS-Login. We are stuck with Metadata-based logins (hence the setup of metadata) in the configuration Region and image id should be parametrized with variables as well Outputs With Terraform we can define the outputs of each terraform apply run. In this case it’s useful to get, for each VM, its id public IP address so we can connect to continue with the configuration. output &quot;instances&quot; { value = &quot;${join(&quot;,&quot;, google_compute_instance.gce-free-tier.*.instance_id, google_compute_instance.gce-free-tier.*.network_interface.0.address, google_compute_instance.gce-free-tier.*.network_interface.0.access_config.0.assigned_nat_ip)}&quot; } Variables To avoid hard coding values in the configuration, I used a separate file to define runtime variables that can be overridden if necessary: variable &quot;public_key_path&quot; { description = &quot;Path to file containing public key&quot; default = &quot;~/.ssh/id_rsa_gcloud.pub&quot; } variable &quot;private_key_path&quot; { description = &quot;Path to file containing private key&quot; default = &quot;~/.ssh/id_rsa_gcloud&quot; } variable &quot;project_id&quot; { description = &quot;Google Cloud Project ID&quot; } variable &quot;ssh_user&quot; { description = &quot;SSH User&quot; } Conclusions I showed you how to automatically setup a completely free (but somewhat limited) 1-VM cluster in Google Cloud and Terraform. Keep up with the updates in the GitHub repository: I’m going to expand the cluster with more Google Cloud free tier perks."><link rel=canonical href=https://ferrarimarco.info/blog/cloud/2018/05/09/google-cloud-engine-free-terraform/ ><meta property=og:url content=https://ferrarimarco.info/blog/cloud/2018/05/09/google-cloud-engine-free-terraform/ ><meta property=og:site_name content="Marco Ferrari - software engineer"><meta property=og:type content=article><meta property=article:published_time content=2018-05-09T00:00:00+00:00><script type=application/ld+json>{"description":"Recently I had to evaluate cloud computing offers for a new project. I started with Google Cloud Platform. Google Cloud: Free Tier For my evaluation goals the always-free tier was enough. This free tier has many perks (at IaaS and PaaS), but for this exercise we will use: 1x free f1-micro VM on Compute Engine with 30GB of disk space 5GB of Google Cloud Storage Goals We are going to bootstrap a 1-VM cluster on Google Cloud Compute Engine using Terraform. The VM will have a 30GB hard disk. Terraform Terraform is tool to automate the provision of cloud infrastructures. Basically it translate a descriptor (Configurations in Terraform jargon) in calls to the chosen cloud provider API. The fancy name for this management process is “Infrastructure as Code”. Infrastructure as Code Why should you describe your infrastructure with code? For three reasons: It will be auditable: you know what’s in there It can be versioned: you can control the changes It can automatically processed: there are tools that can process your infrastructure descriptors and automatically apply changes Terraform Configurations The whole project is available on GitHub: ferrarimarco/google-cloud-playground Being this a really simple infrastructure, we used just three configurations Resources: gce.tf Outputs: outputs.tf Variables: variables.tf Resources In this configuration we define the following resources: A backend Default provider credentials A reginal Google Compute Engine IP Address A Virtual Machine Backend A backend is needed to share the Terraform state, if you want to collaborate with others on the management activities of the infrastructure. You could avoid setting up a backend (Terraform will use a local backend by default), but then you need to deal with the inevitable merging conflicts due to Terraform executions by different users. I configured it because with a remote backend I’m able to modify my infrastructure from any workstation. To keep this in the same infrastructure, I manually created a Google Cloud Storage bucket and configured it in the resources configuration as: terraform { backend &quot;gcs&quot; { credentials = &quot;account.json&quot; prefix = &quot;terraform/state&quot; } } where account.json is a credential file created as described in the README. Default Provider Configuration These are the default settings that we configured for the Google Cloud provider. Can be overridden by other resources. provider &quot;google&quot; { credentials = &quot;${file(&quot;account.json&quot;)}&quot; project = &quot;${var.project_id}&quot; region = &quot;us-east1&quot; zone = &quot;us-east1-b&quot; } Note the use of variables (${}). We’ll explain this later. Google Compute Engine: IP Address and VM Now let’s get to the meat: the Virtual Machine and its public IP address. The syntax is straightforward. resource &quot;google_compute_address&quot; &quot;regional-m1-ip&quot; { name = &quot;regional-m1-ip&quot; } resource &quot;google_compute_instance&quot; &quot;gce-free-tier&quot; { name = &quot;gce1&quot; machine_type = &quot;f1-micro&quot; tags = [&quot;free-tier&quot;] boot_disk { auto_delete = true initialize_params { image = &quot;ubuntu-os-cloud/ubuntu-1804-bionic-v20180426b&quot; size = 30 type = &quot;pd-standard&quot; } } metadata { ssh-keys = &quot;${var.ssh_user}:${file(&quot;${var.public_key_path}&quot;)}&quot; } network_interface { access_config { nat_ip = &quot;${google_compute_address.regional-m1-ip.address}&quot; } subnetwork = &quot;default&quot; } service_account { scopes = [ &quot;https://www.googleapis.com/auth/devstorage.read_only&quot;, &quot;https://www.googleapis.com/auth/logging.write&quot;, &quot;https://www.googleapis.com/auth/monitoring.write&quot;, &quot;https://www.googleapis.com/auth/servicecontrol&quot;, &quot;https://www.googleapis.com/auth/service.management.readonly&quot;, &quot;https://www.googleapis.com/auth/trace.append&quot; ] } } A couple of notes: Terraform does not yet support OS-Login. We are stuck with Metadata-based logins (hence the setup of metadata) in the configuration Region and image id should be parametrized with variables as well Outputs With Terraform we can define the outputs of each terraform apply run. In this case it’s useful to get, for each VM, its id public IP address so we can connect to continue with the configuration. output &quot;instances&quot; { value = &quot;${join(&quot;,&quot;, google_compute_instance.gce-free-tier.*.instance_id, google_compute_instance.gce-free-tier.*.network_interface.0.address, google_compute_instance.gce-free-tier.*.network_interface.0.access_config.0.assigned_nat_ip)}&quot; } Variables To avoid hard coding values in the configuration, I used a separate file to define runtime variables that can be overridden if necessary: variable &quot;public_key_path&quot; { description = &quot;Path to file containing public key&quot; default = &quot;~/.ssh/id_rsa_gcloud.pub&quot; } variable &quot;private_key_path&quot; { description = &quot;Path to file containing private key&quot; default = &quot;~/.ssh/id_rsa_gcloud&quot; } variable &quot;project_id&quot; { description = &quot;Google Cloud Project ID&quot; } variable &quot;ssh_user&quot; { description = &quot;SSH User&quot; } Conclusions I showed you how to automatically setup a completely free (but somewhat limited) 1-VM cluster in Google Cloud and Terraform. Keep up with the updates in the GitHub repository: I’m going to expand the cluster with more Google Cloud free tier perks.","author":{"@type":"Person","name":"Marco Ferrari"},"@type":"BlogPosting","url":"https://ferrarimarco.info/blog/cloud/2018/05/09/google-cloud-engine-free-terraform/","headline":"Bootstrapping a Cluster on Google Cloud with Terraform","dateModified":"2018-05-09T00:00:00+00:00","datePublished":"2018-05-09T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ferrarimarco.info/blog/cloud/2018/05/09/google-cloud-engine-free-terraform/"},"@context":"http://schema.org"}</script><link href="https://fonts.googleapis.com/css?family=Roboto+Slab|Roboto" rel=stylesheet type=text/css></head><body><header class=site-header><div class=wrapper><!--[if lt IE 11]>
      <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]--> <a class=site-title href=/ >Marco Ferrari - software engineer</a><nav class=site-nav><div class=trigger><a class=page-link href=/blog/ >Blog</a></div></nav></div></header><div class=page-content><div class=wrapper><article class=post itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Bootstrapping a Cluster on Google Cloud with Terraform</h1><div class=post-meta><p><time datetime=2018-05-09T00:00:00+00:00 itemprop=datePublished><a href=/blog/archive/2018/ >2018</a>-<a href=/blog/archive/2018/05/ >05</a>-09</time></p></div></header><div class=post-content itemprop=articleBody><p>Recently I had to evaluate cloud computing offers for a new project. I started with <a href=https://cloud.google.com/ >Google Cloud Platform</a>.</p><h1 id=google-cloud-free-tier>Google Cloud: Free Tier</h1><p>For my evaluation goals the <a href=https://cloud.google.com/free>always-free tier</a> was enough.</p><p>This free tier has many perks (at IaaS and PaaS), but for this exercise we will use:</p><ul><li>1x free <a href=https://cloud.google.com/compute/docs/machine-types#sharedcore>f1-micro</a> VM on <a href="https://cloud.google.com/compute/?hl=it">Compute Engine</a> with 30GB of disk space</li><li>5GB of Google Cloud Storage</li></ul><h1 id=goals>Goals</h1><p>We are going to bootstrap a 1-VM cluster on Google Cloud Compute Engine using <a href=https://www.terraform.io/ >Terraform</a>. The VM will have a 30GB hard disk.</p><h2 id=terraform>Terraform</h2><p>Terraform is tool to automate the provision of cloud infrastructures. Basically it translate a descriptor (<a href=https://www.terraform.io/docs/configuration/ >Configurations</a> in Terraform jargon) in calls to the chosen cloud provider API. The fancy name for this management process is <a href=https://en.wikipedia.org/wiki/Infrastructure_as_Code>“Infrastructure as Code”</a>.</p><h2 id=infrastructure-as-code>Infrastructure as Code</h2><p>Why should you describe your infrastructure with code? For three reasons:</p><ol><li>It will be auditable: you know what’s in there</li><li>It can be versioned: you can control the changes</li><li>It can automatically processed: there are tools that can process your infrastructure descriptors and automatically apply changes</li></ol><h1 id=terraform-configurations>Terraform Configurations</h1><p>The whole project is available on GitHub: <a href=https://github.com/ferrarimarco/google-cloud-playground>ferrarimarco/google-cloud-playground</a></p><p>Being this a really simple infrastructure, we used just three configurations</p><ol><li>Resources: <a href=https://github.com/ferrarimarco/google-cloud-playground/blob/master/terraform/gce.tf>gce.tf</a></li><li>Outputs: <a href=https://github.com/ferrarimarco/google-cloud-playground/blob/master/terraform/outputs.tf>outputs.tf</a></li><li>Variables: <a href=https://github.com/ferrarimarco/google-cloud-playground/blob/master/terraform/variables.tf>variables.tf</a></li></ol><h2 id=resources>Resources</h2><p>In this configuration we define the following resources:</p><ol><li>A <a href=https://www.terraform.io/docs/backends/index.html>backend</a></li><li>Default provider credentials</li><li>A reginal Google Compute Engine IP Address</li><li>A Virtual Machine</li></ol><h3 id=backend>Backend</h3><p>A backend is needed to share the Terraform <a href=https://www.terraform.io/docs/state/index.html>state</a>, if you want to collaborate with others on the management activities of the infrastructure. You could avoid setting up a backend (Terraform will use a local backend by default), but then you need to deal with the inevitable merging conflicts due to Terraform executions by different users. I configured it because with a remote backend I’m able to modify my infrastructure from any workstation.</p><p>To keep this in the same infrastructure, I manually created a Google Cloud Storage bucket and configured it in the resources configuration as:</p><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>terraform {
  backend "gcs" {
    credentials = "account.json"
    prefix  = "terraform/state"
  }
}
</code></pre></div></div><p>where <code class=highlighter-rouge>account.json</code> is a credential file created as described in the <a href=https://github.com/ferrarimarco/google-cloud-playground>README</a>.</p><h3 id=default-provider-configuration>Default Provider Configuration</h3><p>These are the default settings that we configured for the Google Cloud provider. Can be overridden by other resources.</p><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>provider "google" {
  credentials = "${file("account.json")}"
  project     = "${var.project_id}"
  region = "us-east1"
  zone = "us-east1-b"
}
</code></pre></div></div><p>Note the use of variables (<code class=highlighter-rouge>${}</code>). We’ll explain this later.</p><h3 id=google-compute-engine-ip-address-and-vm>Google Compute Engine: IP Address and VM</h3><p>Now let’s get to the meat: the Virtual Machine and its public IP address. The syntax is straightforward.</p><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>resource "google_compute_address" "regional-m1-ip" {
  name = "regional-m1-ip"
}

resource "google_compute_instance" "gce-free-tier" {
  name = "gce1"
  machine_type = "f1-micro"
  tags = ["free-tier"]

  boot_disk {
    auto_delete = true
    initialize_params {
      image = "ubuntu-os-cloud/ubuntu-1804-bionic-v20180426b"
      size = 30
      type = "pd-standard"
    }
  }

  metadata {
    ssh-keys = "${var.ssh_user}:${file("${var.public_key_path}")}"
  }

  network_interface {
    access_config {
      nat_ip = "${google_compute_address.regional-m1-ip.address}"
    }
    subnetwork = "default"
  }

  service_account {
    scopes = [
      "https://www.googleapis.com/auth/devstorage.read_only",
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring.write",
      "https://www.googleapis.com/auth/servicecontrol",
      "https://www.googleapis.com/auth/service.management.readonly",
      "https://www.googleapis.com/auth/trace.append"
    ]
  }
}
</code></pre></div></div><p>A couple of notes:</p><ul><li>Terraform does not yet support <a href=https://cloud.google.com/compute/docs/instances/managing-instance-access>OS-Login</a>. We are stuck with <a href=https://cloud.google.com/compute/docs/instances/adding-removing-ssh-keys>Metadata-based</a> logins (hence the setup of metadata) in the configuration</li><li>Region and image id should be parametrized with variables as well</li></ul><h2 id=outputs>Outputs</h2><p>With Terraform we can define the outputs of each <code class=highlighter-rouge>terraform apply</code> run. In this case it’s useful to get, for each VM, its id public IP address so we can connect to continue with the configuration.</p><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>output "instances" {
  value = "${join(",", google_compute_instance.gce-free-tier.*.instance_id, google_compute_instance.gce-free-tier.*.network_interface.0.address, google_compute_instance.gce-free-tier.*.network_interface.0.access_config.0.assigned_nat_ip)}"
}
</code></pre></div></div><h2 id=variables>Variables</h2><p>To avoid hard coding values in the configuration, I used a separate file to define runtime variables that can be overridden if necessary:</p><div class=highlighter-rouge><div class=highlight><pre class=highlight><code>variable "public_key_path" {
  description = "Path to file containing public key"
  default     = "~/.ssh/id_rsa_gcloud.pub"
}

variable "private_key_path" {
  description = "Path to file containing private key"
  default     = "~/.ssh/id_rsa_gcloud"
}

variable "project_id" {
  description = "Google Cloud Project ID"
}

variable "ssh_user" {
  description = "SSH User"
}
</code></pre></div></div><h1 id=conclusions>Conclusions</h1><p>I showed you how to automatically setup a completely free (but somewhat limited) 1-VM cluster in Google Cloud and Terraform.</p><p>Keep up with the updates in the <a href=https://github.com/ferrarimarco/google-cloud-playground>GitHub repository</a>: I’m going to expand the cluster with more Google Cloud free tier perks.</p></div><div class="post-footer post-meta"><p>Categories: <a href=/blog/archive/category/cloud/ >cloud</a></p><p>Tags: <a href=/blog/archive/tag/google-cloud/ >google-cloud</a> <a href=/blog/archive/tag/terraform/ >terraform</a></p><p>Subscribe <a href=/feed.xml>via RSS</a></p></div></article></div></div><footer class=site-footer><div class=wrapper><h2 class=footer-heading>Contacts</h2><div class=footer-col-wrapper><div class=footer-col><ul class=contact-list><li>Marco Ferrari - CV: <a href=https://bit.ly/ferrari-marco-cv-eng class=bold>ENG </a><a href=https://bit.ly/ferrari-marco-cv-ita class=bold>ITA</a></li><li><a href=mailto:ferrari.marco@gmail.com><span class=icon><img src=/assets/images/contacts/email.png> </span><span class=username>Email: ferrari.marco@gmail.com</span></a></li><li><a href=https://github.com/ferrarimarco rel=me><span class=icon><img src=/assets/images/contacts/github.png> </span><span class=username>Github: ferrarimarco</span></a></li><li><a href=https://www.facebook.com/ferrari.marco rel=me><span class=icon><img src=/assets/images/contacts/facebook.png> </span><span class=username>Facebook: ferrari.marco</span></a></li><li><a href=https://www.linkedin.com/in/ferrarimark rel=me><span class=icon><img src=/assets/images/contacts/linkedin.png> </span><span class=username>Linkedin: ferrarimark</span></a></li><li><a href=https://stackoverflow.com/users/653462 rel=me><span class=icon><img src=/assets/images/contacts/stackoverflow.png> </span><span class=username>Stackoverflow: marco-ferrari</span></a></li></ul></div></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
    function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
    e=o.createElement(i);r=o.getElementsByTagName(i)[0];
    e.src='//www.google-analytics.com/analytics.js';
    r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
    ga('create','UA-18832248-1');ga('send','pageview');</script><script src=/assets/javascript/index-8971778a9c.min.js></script></body></html>